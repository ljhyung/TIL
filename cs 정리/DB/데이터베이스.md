### 데이터베이스의 특징

1. 실시간 접근성 (Real-time Accessibility) : 비정형적인 질의(조회) 즉 사용자의 요청에 즉시 처리하여 응답

2. 계속적인 변화 (Continuos Evolution) : 데이터베이스의 상태는 동적으로 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지

3. 동시 공유 (Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 공유, 이용할 수 있어야 한다

4. 내용에 의한 참조 (Content Reference) : db에 있는 data를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾는다

5. 데이터의 독립성 (Independence) : 논리적 독립성 (응용 프로그램과 데이터베이스를 독립)과 물리적 독립성 (응용 프로그램과 보조기억장치 등의 물리적 장치를 독립)을 가짐

### 데이터베이스 언어(DDL, DML, DCL)

#### DDL(데이터 정의어 : Data Definition Language)

- 데이터베이스 구조를 정의, 수정, 삭제하는 언어

- 데이터베이스의 논리적 물리적 구조 정의 및 병경 및 스키마 제약조건 정의

- alter
  
  ```sql
  ALTER TABLE t_wating_customer
      ADD CONSTRAINT FK_t_wating_customer_customer_seq_t_customer_customer_seq FOREIGN KEY (customer_seq)
          REFERENCES t_customer (customer_seq) ON DELETE RESTRICT ON UPDATE RESTRICT;
  ```

- create

- drop

#### DML(데이터 조작어 : Data manipulation Language)

- 데이터 처리를 위한 사용자와 DBMS 사이의 인터페이스를 위한 언어

- 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 (select, insert, update, delete)

#### DCL(데이터 제어어 : Data Control Language)

- 데이터 보안 : 권한이 없는 접근으로부터 데이터베이스를 보호

- 데이터 무결성 : 사용자가 제약 조건을 정의하면 데이터 삽입, 갱신, 삭제마다 검사

- 데이터 회복 : 시스템 오류로부터 데이터베이스를 회복

- 병행 제어 : 여러 사용자가 동시에 데이터베이스를 공유하도록 지원

- 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어

- commit, rollback, grant, revoke

- commit
  
  - 입력한 자료나 수정한 자료에 대해서 또는 삭제한 자료에 대해서 전혀 문제가 없다고 판단되었을 경우 COMMIT 명령어를 통해서 트랜잭션을 완료합니다.

- rollback
  
  - COMMIT 이전에는 변경 사항을 취소 할 수 있는데 데이터베이스에서 ROLLBACK 기능을 사용합니다.
    
    ROLLBACK 은 데이터 변경 사항이 취소되어 데이터의 이전 상태로 복구되며, 관련된 행에 대한 잠금이 풀리고 다른 사용자들이 데이터를 변경 할 수 있습니다.

### SELECT 쿼리의 수행 순서

FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > ORDER BY > DISTINCT > LIMIT

#### 자주 사용하는 쿼리들의 순서

조회 테이블 확인(FROM) -> 데이터 추출 조건 확인(WHERE) -> 컬럼 그룹화(GROUP BY) -> 그룹화 조건(HAVING) -> 데이터 추출(SELECT) -> 데이터 순서 정렬(ORDER BY)

**1. FROM**

- 각 테이블을 확인한다.

**2. ON**

- JOIN 조건을 확인한다.

**3. JOIN**

- JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.

**2. WHERE**

- 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.

**3. GROUP BY**

- WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.

**4. HAVING**

- GROUP BY절이 쿼리에 있을 경우 HAVING 절의 제약조건이 그룹화된 행에 적용된다.

**5. SELECT**

- SELECT에 표현된 식이 마지막으로 적용된다.

**6. DISTINCT**

- 표현된 행에서 중복된 행은 삭제

**7.ORDER BY**

- 지정된 데이터를 기준으로 오름차순, 내림차순 지정

**8. LIMIT**

- LIMIT에서 벗어나는 행들은 제외되어 출력된다.

### 트리거(Trigger)

#### 정의

- 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.

- 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.

#### 종류

1. BEFORE STATEMENT : SQL 구문이 실행되기 전에 그 문장에 대해 한 번 실행 

2. BEFORE ROW : SQL 구문이 실행되기 전에(DML 작업을 수행 전에) 각 행(ROW)에 대해 한 번씩 실행

3. AFTER STATEMENT : SQL 구문이 실행된 후에 그 문장에 대해 한 번 실행

4. AFTER ROW : SQL 구문이 실행된 후에(DML 작업을 수행한 후에) 각 행(ROW)에 대해 한 번씩 실행

#### 구조

```sql
CREATE [ OR REPLACE ] TRIGGER 트리거명        
    [ BEFORE | AFTER ]        
    이벤트1 [ OR 이벤트2 [ OR 이벤트3 ] ] ON 테이블명   -- 장착되는 테이블
    [ FOR EACH ROW [WHEN TRIGGER 조건] ]               
DECLARE       
-- 선언 구문        
(...)
BEGIN        
-- 실행 구문        
(...)
END;
```

#### 예시

```sql
CREATE OR REPLACE TRIGGER TRG_EVENTLOG      
    AFTER             
    INSERT OR UPDATE OR DELETE ON TBL_TEST1             
    -- (FOR EACH ROW... 생략시 기본으로 STATEMENT로 사용)
BEGIN       
-- 이벤트 종류 구분 (조건문을 통한 분기)       
    IF (INSERTING)           
        THEN INSERT INTO TBL_EVENTLOG(MEMO)                   
            VALUES( 'INSERT 쿼리가 실행되었습니다.' );       
    ELSIF (UPDATING)           
        THEN INSERT INTO TBL_EVENTLOG(MEMO)                   
            VALUES( 'UPDATE 쿼리가 실행되었습니다.' );       
    ELSIF (DELETING)           
        THEN INSERT INTO TBL_EVENTLOG(MEMO)                   
            VALUES( 'UPDATE 쿼리가 실행되었습니다.' );       
    END IF;

-- COMMIT;       --> 트리거 내에서는 COMMIT / ROLLBACK 사용 불가
END;
--==>> Trigger TRG_EVENTLOG이(가) 컴파일되었습니다.
```

트리거는 **데이터베이스에 의해 자동 호출되지만 결국 INSERT, UPDATE, DELETE 구문과 하나의 트랜잭션 안에서 일어나는 일련의 작업들이라 할 수 있습니다.**

-> 트리거 내에서 COMMIT, ROLLBACK 사용 불가

### Index

- Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 <u>인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법</u>입니다.
  
  - 예를들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것이다.

- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.

- 즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.

https://velog.io/@gillog/SQL-Index%EC%9D%B8%EB%8D%B1%EC%8A%A4

### 정규화

하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

제1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value; 하나의 값)을 갖도록 분해합니다.

제2 정규형: 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 <u>완전 함수 종속</u>이도록 분해합니다. 

※ 여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미

제3 정규형 : 제2 정규형을 만족하고, <u> 이행적 함수 종속</u>을 없애도록 분해합니다. 

※ 여기서 이행적 종속이란 A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미

BCNF 정규형 : 제3 정규형을 만족하고, 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.

#### 정규화 장단점

**장점**

1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.

2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

**단점**

릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.

+ 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

### 역정규화

정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다. 

역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.

![](assets/2022-07-23-20-02-35-image.png)

### 이상 현상의 종류에 대해 설명해주세요.

- 이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입,삭제,수정할 때 생기는 논리적 오류를 말합니다.
1. **삽입 이상** : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상

2. **갱신 이상** : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상

3. **삭제 이상** : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상
- 이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 합니다.

### SQL Injection이란

SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.

### SQL Injection 방어 및 방지

1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.

2. 저장 프로시저를 사용합니다.

※ 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.

### RDBMS와 NoSQL의 차이

**RDBMS**는 모든 데이터를 2차원 테이블 형태로 표현합니다.

- 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
- 단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

**NoSQL**(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.

- **장점** : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다. 
- 데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.
- **단점** : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다. 
- 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다. 

#### DB를 확장하는 두가지 방법 - scale out, scale up

- scale out
  
  - **접속된 서버를 여러 대 추가하여 처리 능력을 향상하는 방법**
  
  - **수평 스케일**로 불리기도 한다. 예를 들어, 하나의 처리 능력을 가진 서버에 동일한 서버 6대를 더 추가하여, 총 7의 처리 능력을 만드는 것이다.
  
  - 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 ‘로드밸런싱’이 필수적으로 동반되어야 한다. 그리고 스케일 아웃의 경우, 서버 한 대가 장애로 다운되더라도 다른 서버로 서비스 제공이 가능하다는 장점이 있다.
  
  - 각각의 처리는 비교적 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안 되는 경우 적합한데 갱신 데이터의 정합성(데이터가 서로 모순 없이 일관되게 일치해야 하는 경우) 유지에 대한 요건이 별로 어렵지 않은 경우에 적절하다. 즉 높은 병렬성을 실현하기 쉬운 경우이다. 
  
  - 모든 서버가 동일한 데이터를 가지고 있어야 하므로, 데이터 변화가 적은 ‘웹 서버’에 적합한 방식이며, 웹 서버 펌, 데이터가 읽기 전용인 검색엔진 데이터 분석 처리 VOD(주문형 비디오) 일부의 과학기술 계산, 메일 서버나 게시판 등의 어플리케이션 등에 적용할 수 있다. 

- scale up
  
  - 서버에 CPU나 RAM 등을 추가하거나 **고성능의 부품, 서버로 교환하는 방법**
  
  - 하나의 처리 능력을 가진 서버 한 대를 7의 처리 능력을 가진 서버로 그 자체의 처리능력을 향상시키는 것이다. **수직 스케일**로 불리기도 한다.
  
  - CPU나 RAM을 추가하기 부품을 장착할 수 있는 여유 슬롯이 있어야 하며, 그렇지 않은 경우 서버 자체를 고성능으로 교체하는 것이 필요하다.스케일 업의 경우, 서버 한 대로 모든 부하가 집중되므로 장애 시 영향을 크게 받을 수 있는 위험성이 있다.
  
  - 한 대의 서버에서 모든 데이터를 처리하므로 데이터 갱신이 빈번하게 일어나는 ‘데이터베이스 서버’에 적합한 방식이다. 빈번히 갱신으로 여러 대의 서버에서는 정합성(데이터가 서로 모순 없이 일관되게 일치해야 하는 경우) 유지가 어렵기 때문이다.

#### 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?

- **RDBMS**는 <u>데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.</u> 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
- **NoSQL**은 <u>정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다.</u> 또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합합니다.

### 트랜잭션(Transaction)

- 트랜잭션은 작업의 완전성을 보장해줍니다. 
- 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
- 하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.

#### 트랜잭션의 특성(ACID)

1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.

2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.

3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.

4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.

### DB Lock

- DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.
- **공유락**(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.
- **베타락**(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.

### Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이

- Elasticsearch는 텍스트, 숫자, 위치 기반 정보, 정형 및 비정형 데이터 등 모든 유형의 데이터를 위한 무료 검색 및 분석 엔진으로 분산형과 개방형을 특징으로 합니다.
- RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다. 
- (MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하긴 하지만, 한글 검색의 경우 아직 많이 빈약한 감이 있습니다.)
- 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다.

※ Full-Text : 이미지, CSS, 글 등의 복합적으로 이뤄진 컨텐츠에서 순수하게 텍스트만 추출한 데이터를 의미. 이 과정을 보통 크롤링으로 구현함 ( 엘라스틱 서치의 검색엔진엔 크롤러가 빠져있어 별도로 구축해야함)

### 옵티마이저(Optimizer)

- 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
- 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.

| 항목  | 규칙 기반 옵티마이저                    | 비용 기반 옵티마이저                   |
| --- | ------------------------------ | ----------------------------- |
| 개념  | 사전에 정의된 규칙 기반                  | 최소비용 계산 실행계획 수립               |
| 기준  | 실행우선 순위(Ranking)               | 액세스 비용(Cost)                  |
| 인덱스 | 인덱스 존재 시 가장 우선시 사용             | Cost에 의한 결정                   |
| 성능  | 사용자 SQL작성 숙련도                  | 옵티마이저 예측 성능                   |
| 장점  | 판단이 매우 규칙적 실행 예상 가능            | 통계 정보를 통한 현실 요소 적용            |
| 단점  | 예측 통계정보 요소 무시                  | 최소 성능 보장 계획의 예측 제어 어려움        |
| 사례  | AND 중심 양쪽 '=' 시 Index Merge 사용 | AND 중심 양쪽 '=' 시 분포도별 Index 선택 |

### DB Tuning과 튜닝의 3단계

- DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다. 

- 튜닝은 DB 설계 튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.

- 1단계 - DB 설계 튜닝(모델링 관점)
  
  - DB 설계 단계에서 성능을 고려하여 설계
  - 데이터 모델링, 인덱스 설계
  - 데이터파일, 테이블 스페이스 설계
  - 데이터베이스 용량 산정
  - **튜닝 사례** - 반정규화, 분산파일배치

- 2단계 - DBMS 튜닝(환경 관점)
  
  - 성능을 고려하여 메모리나 블록 크기 지정
  - CPU, 메모리 I/O에 관한 관점
  - **튜닝 사례** - Buffer 크기, Cache 크기

- 3단계 - SQL 튜닝(App 관점)
  
  - SQL 작성 시 성능 고려
  - Join, Indexing, SQL Execution Plan
  - **튜닝 사례** - Hash / Join

### inner join과 outer join의 차이

**inner join** 은 <u>서로 연관된 내용만 검색하는 조인 방법입니다.</u>

 A와 B에 대해 수행하는 것은, A와 B의 교집합을 말합니다. 벤다이어그램으로 그렸을 때 교차되는 부분입니다.

**outer join** 은 <u>한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법입니다.</u>

A와 B에 대해 수행하는 것은, A와 B의 합집합을 말합니다. 벤다이어그램으로 그렸을 때 합집합 부분입니다.

outer join에는 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있습니다.

![](https://blog.kakaocdn.net/dn/m9mAg/btrt4hUhaE8/EOorXRpviLk8ROt1WiG6l0/img.jpg)

### Group by

GROUP BY 는 GROUP BY 명령어를 통해 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역할을 합니다.

집합 연산자는 COUNT, SUM, AVG, MAX, MIN 등이 있고, DISTINCT와 같이 중복 데이터를 제거하는 특징이 있습니다.

#### Having

GROUP BY 절에서 조건을 주려면 WHERE이 아닌, **HAVING** 절을 사용해야 합니다.

위의 SELECT 실행 순서를 보면 WHERE 절이 GROUP BY 보다 먼저 실행되기 때문에, GROUP BY에 대응되는 HAVING절이 있습니다.

HAVING 은 GROUP BY 뒤에 작성하며, WHERE와 동일한 형식으로 조건을 작성할 수 있습니다.

### DELETE, TRUNCATE, DROP의 차이를 설명해주세요.

**DELETE는** 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 되돌릴 수 있습니다.

**TRUNCATE는** 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고,  삭제 후 되돌릴 수 없습니다.

**DROP은** 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제 후 되돌릴 수 없습니다.

### ORM

ORM은 객체와 관계형 데이터베이스 매핑의 줄임말이며, OOP에서 쓰는 객체라는 개념을 구현한 클래스와 RDB에서 쓰이는 데이터 테이블을 매핑하는 것을 의미합니다.

### Having과 Where의 차이

**having**은 그룹을 필터링 하는데 사용되고, **where**은 개별 행을 필터링하는데 사용됩니다.

집계 함수(COUNT, SUM, AVG, MAX, MIN 등)는 having절과 함께 사용할 수 있으나, 

where절은 사용할 수 없습니다.( 집계함수를 사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저 수행)

<u><span><b>having</b>은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,</span></u>

<u><span><b>where</b>은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용됩니다.</span></u>

### Join에서 on과 where의 차이

**ON** 이 **WHERE** 보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)

WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)

On -> Join -> where

 수정
