### 1. 다형성(polymorphism)이란?

다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.

자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다.

다형성을 활용하면 부모 클래스가 자식 클래스의 동작 방식을 알 수 없어도 오버라이딩을 통해 자식 클래스를 접근할 수 있습니다.

부모가 자식이 어떤 일을 하는 지 몰라도, 자식 멤버 함수를 호출할 수 있는 이유는 `동적 바인딩` 때문입니다.

> **동적 바인딩** : 동적바인딩이란, 메소드가 실행 시점에서 성격이 결정되는 바인딩

프로그램의 `컴파일 시점`에 부모 클래스는 자신의 멤버 함수밖에 접근할 수 없으나,

`실행 시점`에 동적 바인딩이 일어나 부모클래스가 자식 클래스의 멤버함수를 접근하여 실행할 수 있습니다.

---

### 2. 참조 변수의 다형성

다음 예제는 참조 변수의 다형성을 보여주는 예제입니다.

```java
import java.util.*;

class parent {
    public void printParent() {
        System.out.println("부모입니다.");
    }
}

class father extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 아버지입니다.");
    }
}

class mother extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 어머니입니다.");
    }
}

public class Main{

    public static void main(String[] args) {
        //Question
        parent parent = new parent();
        father father = new father();
        parent parentActFather = new father();
        parent parentActMother = new mother();
        father childParent =  new parent();

        parent.printParent();

        parentActFather.printParent();
        parentActMother.printParent();
    }
}
```

**다형성 구현 방법**

1. 상속 클래스 구현 (부모-자식 클래스 구현)

```java
class parent {
    public void printParent() {
        System.out.println("부모입니다.");
    }
}

class father extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 아버지입니다.");
    }
}
```

1. 메소드 오버라이딩

```java
class mother extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 어머니입니다.");
    }
}
```

1. 업캐스팅하여 객체 선언

```java
parent parentActFather = new father();
parent parentActMother = new mother();
```

1. 부모 클래스 객체로 자식 메소드 호출

```java
parentActFather.printParent();
parentActMother.printParent();
```

**자바에서 참조 변수는 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.**

특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문입니다.

```java
가능) parent parent = new parent();
```

그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문입니다.

```java
    가능) parent parentActFather = new father();
```

하지만 반대의 경우인 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문입니다.

```java
불가능) father childParent = new parent();
```

클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 됩니다.

---

### 3. 참조 변수의 타입 변환

자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.

1. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.

```java
가능)     parent parentActFather = new father();
불가능)     mother motherFather = new father(); 
```

2. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.

```java
parent parent = new parent();
father father = new father();
parent parentActFather = null;

//아래 두개는 같음
parentActFather = father;
parentActFather = (parent)father;
```

1. 부모 클래스 타입은 자식 클래스 타입으로 타입 변환을 할 수 없습니다.

```java
father father = null;
// 에러 발생) 
father f = new parent();

// 에러는 발생하지 않지만 java.lang.ClassCastException 예외 발생
father f = (father) new parent();
```

---

### 4. instanceof 연산자

```java
class parent {
    public void printParent() {
        System.out.println("부모입니다.");
    }
}

class father extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 아버지입니다.");
    }
    public void printFather() {
        System.out.println("전 아버지입니다.");
    }
}

class mother extends parent {
    @Override
    public void printParent() {
        super.printParent();
        System.out.println("전 부모 중 어머니입니다.");
    }
    public void printMother() {
        System.out.println("전 어머니입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        parent father = new father();
        father.printFather();
    }
}
```

위의 `father.printFather()` 는 실행이 안됩니다.

father은 parent 형인데 parent 형에는 `printFather()` 함수가 없기 때문입니다.

이런 경우 데이터 형에 맞게 캐스팅을 해준 뒤 메소드를 사용해야 합니다.

```java
((father) father).printFather();
```

이런 번거로운 과정을 거치는 이유는 parent 클래스는 자신을 상속받은 클래스 중에서 어떤 메소드를 만들지, 어떤 멤버 변수를 만들지 알 수 없기 때문입니다.

따라서 그 메소드가 있는 객체로 직접 캐스팅을 해주어야 메소드를 사용할 수 있습니다.

아래는 메모리에 father객체가 저장된 모습입니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76c8d4ee-26cc-416b-a6b2-32f7898cbb60/Untitled.png)

parent는 printParent()밖에 없기 때문에 printParent() 밖에 사용할 수 없습니다.

하지만 객체를 생성할 때 new father()를 통해 동적으로 메모리를 할당해주었기 때문에 father는 실제 메모리에는 올라가 있습니다.

따라서 형변환을 하면 printFather()를 사용할 수 있는 것입니다.

이러한 다형성이 사용되는 곳은 매개변수로 부모 클래스를 받아줄 때 사용됩니다.

```java
public class Main {
    public static void func(parent parent) {
        ...
    }

    public static void main(String[] args) {
        parent father = new father();
        parent mother = new mother();

        ((father) father).printFather();
        func(father);
        func(mother);
    }
}
```

하지만 func 함수가 모든 parent 타입의 객체를 받을 수는 있지만 그것이 father인지 mother인지 알아야 각각의 클래스에 있는 고유한 메소드를 사용해줄 수 있을 것입니다.

그래서 필요한 것이 `instanceof` 연산자입니다.

instanceof를 사용한다면 인스턴스의 실제 타입을 확인할 수 있습니다.

```java
public class Main {
    public static void func(parent parent) {
        if(parent instanceof father) {
            ((father)parent).printFather();
        }
        else if(parent instanceof mother) {
            ((mother)parent).printMother();
        }
    }

    public static void main(String[] args) {
        parent father = new father();
        parent mother = new mother();

        ((father) father).printFather();
        func(father);
        func(mother);
    }
}
```

---

### 다형성 장점

1. 유지보수가 쉽다 개발자가 여러 객체를 하나의 타입으로 관리가 가능하기 때문에 코드 관리가 편리해 유지보수가 용이합니다.
2. 재사용성 증가 다형성을 활용하면 객체를 재사용하기 쉬워지기 때문에 개발자의 코드 재사용성이 높집니다.
3. 느슨한 결합 다형성을 활용하면 클래스간 의존성이 줄어들며 확장성이 높고 결합도가 낮아져 안전성이 높아집니다.

---

### 면접 예상 질문

1. Q. 다형성이란 무엇인가?
   
   A. 다형성은 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것입니다.
   
   상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해주고, 같은 클래스 내의 코드를 줄여줄 수 있습니다.
   
   오버라이딩이나 오버로딩을 통해 한 요소가 여러 개념을 가질 수 있습니다.

2. Q. 오버로딩과 오버라이딩에 대해 설명해보세요.
   
   A. 오버로딩은 같은 이름의 메소드를 매개변수의 개수 혹은 타입을 다르게 해 여러 개 사용하는 것입니다.
   기존에 없던 새로운 메소드를 정의하는 것이고 메소드명을 절약할 수 있습니다.
   오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용하는 것입니다.
   상황에 맞게 상속받은 메소드를 변경해야하는 경우 오버라이딩을 사용합니다.
