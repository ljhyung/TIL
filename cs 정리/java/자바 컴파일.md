![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8919623a-8fb9-4a6f-98b6-1f02c9b157f2/Untitled.png)

1. 개발자가 소스코드(.java) 작성
2. 자바 컴파일러가 .java 파일을 컴파일 → **바이트 코드**(.class)
   1. 바이트 코드는 컴퓨터가 못읽고 **JVM**이 읽을 수 있는 코드
3. 바이트 코드를 JVM의 **class loader**에게 전달
4. class loader는 **동적로딩(dynamic loading)**을 통해 클래스들을 로딩 및 링크하여 런타임 데이터 영역(runtime data area - jvm 메모리 영역)에 적재
   1. class loader 세부 동작
      1. **로드** : .class 파일 jvm 메모리에 적재
      2. **검증** : 자바 언어 명세 및 jvm 명세에 명시된 대로 구성 되어있는지 검사
      3. **준비** : 클래스가 필요로 하는 크기의 메모리 할당(필드, 메서드, 인터페이스 등등)
      4. **분석** : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
      5. **초기화** : 클래스 변수들을 적절한 값으로 초기화(static)
5. 실행엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위 하나씩 실행
   1. 인터프리터 방식 : 바이트 코드 하나씩 일고 해석 후 실행
      1. 코드 각각의 실행속도는 좋으나
      2. 전체적인 코드의 실행속도는 느리다
   2. JIT(Just-In-Time) 컴파일러 방식 : 바이트 코드 전체를 컴파일후 2진코드로 변경
      1. 컴파일된 2진 코드이기 때문에 실행 속도가 인터프리터 방식보다 빠름
