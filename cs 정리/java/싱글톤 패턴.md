### 싱글톤 패턴이란?

- 어떤 클래스의 **인스턴스가 오직 하나임을 보장**, 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴
- 프로그램 시작부터 종료 시까지 **어떤 클래스의 인스턴스가 메모리 상에 단 하나만 존재**할 수 있게 하고 이 인스턴스에 대해 어디에서나 접근할 수 있도록 하는 패턴

### 왜 만들어졌을까?

- 어떤 클래스에 대해 단 하나의 인스턴스만을 갖도록 하는 것이 좋은 경우가 있다
- 로그를 찍는 객체, 스레드 풀 등...!

### 어떻게 접근?

- 클래스 자신이 자기의 유일한 인스턴스로 접근하는 방법을 자체적으로 관리
- 생성자를 private하게 만들어 클래스 외부에서는 인스턴스를 생성하지 못하게 차단하고, 내부에서 단 하나의 인스턴스를 생성하여 외부에는 그 인스턴스에 대한 방법을 제공할 수 있다.

## 구현 방법

### 공통적인 특징

- **private 생성자만 정의**해 외부 클래스로부터 인스턴스 생성을 차단
- 싱글톤을 구현하고자 하는 클래스 내부에 **멤버 변수로써 private static 객체 변수**를 만듬
- **public static 메소드를 통해 외부에서 싱글톤 인스턴스에 접근할 수 있도록 접점 제공**

### 1. 기본

```java
public class Singleton{
    private static Singleton instance;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(instance == null){ // 1. 스레도 동시 접근 문제
            instance = new Singleton(); // 2. 스레드 동시 접근시 인스턴스 여러번 생성
        }
        return instance;
    }
}
```

- **멀티 스레드 환경**에서 문제가 된다. `if(instance == null)` 지점이 Thread A까지 진행된 뒤 제어권이 Thread B로 넘어간 경우 Thread B 역시 `if(instance == null)` 이 수행되어 instance 생성. 다시 제어권으로 넘어가면 Thread A에서 다시한번 instance가 생성되게 되어 결국 인스턴스 2개가 생성됨!

### DCL(Double-Checked-Locking)

```java
public class Singleton{
    private static Singleton instance;
    private Singleton(){

    }
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
    }
}
```

**synchronized**

- 스레드 동기화 문제 해결
- synchronized 키워드 자체에 대한 비용이 크기 때문에 싱글톤 인스턴스 호출이 잦은 **어플리케이션에서는 성능이 떨어지게 됩니다.**
- 단일 스레드가 대상 메소드를 호출 시작 ~ 종료까지 다른 스레드가 접근하지 못하도록 lock을 해준다.
- getInstance() 내부에서 isntance를 생성하는 경우만 부분적으로 `synchronized`처리를 하여 생성과 획득을 분리한 방법
- 인스턴스가 생성되어 있는지 확인해보고 인스턴스가 없는 경우 lock을 잡고 instance를 생성하는 방법

⚠️ 문제

- 컴파일에 따라서 재배치(reordering) 문제를 야기
  → **`volatile`** 를 이용해서 개선

```java
public class Singleton {

    private volatile static Singleton instance;
    private Singleton(){}

    public static Singleton getInstance() {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**`volatile`**

- 자바 코드의 변수를 메인 메모리에 저장할 것을 명시
- CPU 캐시에서 변수를 참조하지 않고 메인 메모리에서 변수를 참조

### Bill Pugh Singleton Implementation

- 가장 널리 쓰이는 싱글톤 구현 방법
- Singleton 클래스가 Load 될 때에도 Load 되지 않다가 getInstance()가 호출됐을 때 비로소 JVM 메모리에 로드되고, 인스턴스를 생성하게 됩니다.
  아울러 synchronized를 사용하지 않기 때문에 4번에서 문제가 되었던 성능 저하 또한 해결됩니다.

```java
public class Singleton {

    private Singleton(){}

    private static class SingletonHelper{
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
```

### 면접문제

1. 싱글톤 패턴이란?
2. `**volatile**` 키워드?

### 참고

[](https://readystory.tistory.com/116)[[생성 패턴] 싱글톤(Singleton) 패턴을 구현하는 6가지 방법 :: 준비된 개발자](https://readystory.tistory.com/116) [](https://javaplant.tistory.com/21)[[JAVA 디자인패턴] Singleton 패턴의 모든 것 (멀티스레드 고려)](https://javaplant.tistory.com/21)
